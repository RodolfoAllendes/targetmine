<?xml version="1.0"?>

<article>
  
  <artheader>
    <date>2003-10-17</date>
    <title>How to query InterMine</title>
    <authorgroup>
      <author>
        <firstname>Mark</firstname>
        <surname>Woodbridge</surname>
      </author>
    </authorgroup>
  </artheader>
  
  <sect1>
    <para>This document presents an introduction to the general form of query used in InterMine. Actual queries can be specified using a <ulink url="java_query/spec">Java API</ulink> or as <ulink url="iql_query/spec.xml">FQL strings</ulink> (which are transparently mapped to the equivalent Java representation). The examples below are specified in FQL, which is generally more concise and readable that the equivalent Java. They refer to types in the model used by the <ulink url="start/tutorial.xml">tutorial</ulink>, so that the query strings can be directly substituted in to SimpleQuery.java.</para>
  </sect1>
  
  <sect1>
    <title>The components of a query</title>
    <para>InterMine queries are similar to those formulated in SQL, but object oriented in that they refer to (classes of) objects rather than tables, and simpler because they have a more restricted syntax. A query consists of a Select list (of QueryClasses or QueryEvaluables which form the results of the query), a From list (of SubQueries or QueryClasses involved in the query's Select list or constraints) and a Where list of constraints on the objects involved (including fields of these objects and expressions involving them). In addition the results can be grouped or ordered (by QueryClass or QueryEvaluable).</para>
    
    <itemizedlist>
      <listitem><ulink url="../../api/org/intermine/objectstore/query/QueryClass">QueryClass</ulink>es are (constrained) sets of objects of a common superclass. A QueryClass corresponds to a type, though there can be many QueryClasses of a single type in a query. In this case the QueryClasses must be aliased to distinguish between them. Otherwise they are imlicitly aliased with the name of their type. Selecting a superclass will select all the objects of its subclasses:
        <programlisting>select Company from Company
select Employable from Employable</programlisting></listitem>
      
      <listitem><ulink url="../../api/org/intermine/objectstore/query/QueryEvaluable">QueryEvaluable</ulink>s are entities than can be evaluated to a "primitive" type. These include:<itemizedlist><listitem><ulink url="../../api/org/intermine/objectstore/query/QueryField">QueryField</ulink>s  - primitive fields of QueryClasses (eg <synopsis>Employee.name</synopsis>)</listitem><listitem><ulink url="../../api/org/intermine/objectstore/query/QueryValue">QueryValue</ulink>s  - literal values (eg <synopsis>'Alice</synopsis>')</listitem><listitem><ulink url="../../api/org/intermine/objectstore/query/QueryExpression">QueryExpression</ulink>s formed by combinations of other QueryEvaluables (eg <synopsis>65 - Employee.age</synopsis>)</listitem><listitem><ulink url="../../api/org/intermine/objectstore/query/QueryFunction">QueryFunction</ulink>s  - aggregates of fields or expressions (eg <synopsis>select count(*) as employee_count from Employee</synopsis>). Note that SQL GROUP BY rules apply to QueryFunctions (must GROUP BY selected non-aggregate columns), and that count functions in the select list must be aliased.</listitem></itemizedlist></listitem>
      
      <listitem><ulink url="../../api/org/intermine/objectstore/query/QueryReference">QueryReference</ulink>s correspond to the non-primitive (ie object or collection) fields of queryclasses (eg <synopsis>Employee.department</synopsis>)</listitem>
      
      <listitem>Subqueries are queries that are embedded in the From list of another query. They must be aliased. A path-like syntax is used to refer to elements in their Select list:
        <programlisting>select subquery.Company.name as field from (select Company from Company) as subquery</programlisting>
      </listitem>
    </itemizedlist>
    
  </sect1>
  <sect1>
    <title>Constraint types</title>

<itemizedlist><listitem><ulink url="../../api/org/intermine/objectstore/query/SimpleConstraint">SimpleConstraint</ulink>s involve QueryEvaluables and are basically numeric or string comparisons.
Available operators (depending on type) are =, !=, &lt;, &lt;=, &gt;, &gt;=, MATCHES and DOES NOT MATCH.
<programlisting>select Employee from Employee where Employee.age &lt; 65</programlisting></listitem>

<listitem><ulink url="../../api/org/intermine/objectstore/query/ContainsConstraint">ContainsConstraint</ulink>s specify that QueryReferences "contain" other QueryClasses in the sense that a non-primitive field can equal an object (if it represents a reference), or contain an object (if it represents a collection of objects).
Available operators are CONTAINS and DOES NOT CONTAIN.
The following two queries are equivalent:
<programlisting>select Employee from Employee, Department
  where Department.name='DepartmentA1' and Department.employees contains Employee

select Employee from Employee, Department
  where Department.name='DepartmentA1' and Employee.department contains Department</programlisting></listitem>

<listitem><ulink url="../../api/org/intermine/objectstore/query/ClassConstraint">ClassConstraint</ulink>s are used to compare QueryClasses to other QueryClasses or example objects.
Available operators are EQUALS and DOES NOT EQUAL.
<programlisting>select e1, e2 from Employee as e1, Employee as e2, Department
  where e1.department contains Department and e2.department contains Department and e1 != e2

select Employee from Employee where Employee = [example object]</programlisting></listitem>

<listitem><ulink url="../../api/org/intermine/objectstore/query/BagConstraint">BagConstraint</ulink>s correspond to more general "in" constraints where arbitrary (heterogeneous) collections of objects can be filtered by specifying that they "contain" a specific QueryClass. Alternatively the collection can be of primitive types, in which case the constraint is on a QueryEvaluable.
<programlisting>select Company from Company
  where Company in [collection of company objects]

select Company from Company
  where Company.name in [collection of strings]</programlisting></listitem>

<listitem><ulink url="../../api/org/intermine/objectstore/query/SubqueryConstraint">SubqueryConstraint</ulink>s are related to ContainsConstraints are are used where a QueryClass or QueryEvaluable should be present in the results (ie the From list) of a subquery. In practice this means that the results of a subquery contain a certain object, or equal a set of objects. Queries can be added to the from list of another query, and fields added to the top-level Select list by using the alias of the subquery.
Available operators are CONTAINS and DOES NOT CONTAIN.
<programlisting>select Company from Company
  where Company.name in (select Company.name as name from Company)</programlisting></listitem></itemizedlist>
</sect1>
<sect1><title>Notes</title>
<itemizedlist><listitem>Constraints can be arbitrarily combined into (nested) AND or OR sets. Constraint negation can be performed on sets or individual constraints. Note that in some cases it is possible to negate the constraint (DOES NOT CONTAIN), or its condition (NOT CONTAINS), to achieve the same result:
<programlisting>select Company from Company where not Company.name = 'CompanyA'
select Company from Company where Company.name != 'CompanyA'</programlisting></listitem>

<listitem>Queries have a Distinct flag, which, when set, will remove duplicate elements from the results list.
<programlisting>select distinct Contractor, Company from Contractor, Company
  where Contractor.oldComs contains Company</programlisting>
Note that a subquery is necessary to count the number of expected results rows for a distinct query:
<programlisting>select count(*) as c from (select distinct Contractor, Company from Contractor, Company
  where Contractor.oldComs contains Company) as d</programlisting>
whereas a non-distinct query can be counted by replacing the select list: 
<programlisting>select count(*) as c from Contractor, Company where Contractor.oldComs contains Company</programlisting></listitem></itemizedlist>
</sect1>
</article>
