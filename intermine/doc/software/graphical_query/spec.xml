<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
  <articleinfo>
    <title>InterMine - Graphical Query Specification</title>

    <authorgroup>
      <author>
        <firstname>Matthew</firstname>

        <surname>Wakeling</surname>
      </author>
    </authorgroup>
  </articleinfo>

  <section>
    <title>Introduction</title>

    <para>This document is an attempt to create a consistent specification of
    the InterMine query, specifically its graphical representation.</para>
  </section>

  <section>
    <title>Initial description</title>

    <para>Our database stores separate collections of data, where each
    collection stores data all of the same type.</para>

    <mediaobject>
      <imageobject>
        <imagedata align="left" fileref="Gene.png" />
      </imageobject>
    </mediaobject>

    <para>These collections can be compared to tables in SQL or object classes
    in an Object Oriented DB. A query will retrieve data from one or more of
    these collections - so the graphical representation of a query consists of
    an arrangement of objects on the screen, each of which represent one of
    these collections. The figure on the left is an example of such an object,
    which represents the collection of Genes in the database. The object type
    "Gene" is represented as a box, with a title at the top declaring its
    type, and a list of fields in the object below it. <!--	(Note that these aren't necessarily the fields of a Gene object - it is just an example picture.) --></para>

    <mediaobject>
      <imageobject>
        <imagedata align="right" fileref="Gene2.png" />
      </imageobject>
    </mediaobject>

    <para>The picture shown on the right is a complete query - it represents
    "List all genes" - a relatively simple query.</para>

    <para>The query shown on the right is similar - it represents the query
    "List all genes, where the gene field 'A Field' equals 'Hello'." In this
    way, restrictions can be placed on the fields, like the
    <emphasis>where</emphasis> clause in SQL or OQL.</para>
  </section>

  <section>
    <title>Joining multiple object types</title>

    <para>The query on the left shows two object types in a query, joined
    together with a line between Gene.Sequences and Sequence.Genes.</para>

    <mediaobject>
      <imageobject>
        <imagedata align="left" fileref="GeneSequenceR.png" />
      </imageobject>
    </mediaobject>

    <para>Formally, the query results contain every possible combination of
    each Gene with each Sequence, where the restriction represented by the
    line (Gene contains Sequence) is true.</para>

    <mediaobject>
      <imageobject>
        <imagedata align="right" fileref="GeneSequenceR2.png" />
      </imageobject>
    </mediaobject>

    <para>It is also possible to draw a line between two fields of an object,
    with an operator on the line. This type of link (shown on the right) is
    restricting the results so that only results where the "Gene.A field"
    field is equal to the "Sequence.This field" are shown. As well as equals
    (<emphasis>=</emphasis>), there is greater than
    (<emphasis>&gt;</emphasis>), greater or equal
    (<emphasis>&gt;=</emphasis>), not equal (<emphasis>!=</emphasis>), less
    than (<emphasis>&lt;</emphasis>), less or equal
    (<emphasis>&lt;=</emphasis>), and like (which performs a string pattern
    match).</para>

    <mediaobject>
      <imageobject>
        <imagedata align="left" fileref="GeneSequence.png" />
      </imageobject>
    </mediaobject>

    <para>For completeness, the query on the left is also valid - it
    represents "List all possible combinations of every Gene with every
    Sequence." It is not normally useful to produce a query like this.</para>
  </section>

  <section>
    <title>What results actually get shown</title>

    <mediaobject>
      <imageobject>
        <imagedata align="left" fileref="Gene3.png" />
      </imageobject>
    </mediaobject>

    <para>To indicate what data we actually want to see in our results, we
    place tick-marks against all the items we wish to be included.</para>

    <mediaobject>
      <imageobject>
        <imagedata align="right" fileref="GeneSequenceR3.png" />
      </imageobject>
    </mediaobject>

    <para>This can happen on an object-wide level, or field-by-field. For
    instance, the query on the left specifies that all Genes should be listed,
    and they should be shown as a table with a single column, being the gene.
    The query on the right produces a table with two columns - the gene,
    against the sequence field "This field". In a HTML representation of this
    result, clicking on a gene would link to a page describing the gene in
    more detail, whereas clicking on the field "This field" would link to a
    page containing a list of all Sequences that have the save value of "This
    field".</para>
  </section>

  <section>
    <title>Aggregate functions</title>

    <mediaobject>
      <imageobject>
        <imagedata align="right" fileref="GeneSequenceC.png" />
      </imageobject>
    </mediaobject>

    <para>An aggregate function is a function that takes a set of one or more
    rows in a result, and combines them into a single row. In SQL and OQL,
    once can specify a set of fields which the results are to be grouped by,
    and the aggregate will convert each group into a single row. For instance,
    if one needs to show a table of Gene against the number of Sequences it
    contains, one would create a join between Gene and Sequence (to give a
    list of all the combinations of Gene with a Sequence attached to it), then
    group by Gene (to produce a list of groups of Gene-Sequence combinations
    that have the same Gene), and apply the "count" aggregate function to
    reduce each group to the Gene and the count of the rows in the group. We
    represent this type of query by putting a dashed box around the items of
    data that we wish to apply the aggregate to, as in the diagram on the
    right. One can then tick the "count" field in the aggregation (dashed box)
    to indicate that we wish it to be included in the results.</para>

    <mediaobject>
      <imageobject>
        <imagedata align="right" fileref="GeneSequenceCR.png" />
      </imageobject>
    </mediaobject>

    <para>Aggregate functions that are available include
    <emphasis>count</emphasis>, <emphasis>max(a field)</emphasis>,
    <emphasis>min(a field)</emphasis>, <emphasis>sum(a field)</emphasis>, etc.
    Most of the aggregate functions operate on a particular field in the
    aggregation - <emphasis>count</emphasis> is unusual in that it doesn't do
    this.</para>

    <para>The field created by the aggregate function can be referred to in
    exactly the same way as any of the other fields in any objects. For
    instance, the diagram on the right is a query that lists all Genes that
    have more than five sequences attached to them.</para>
  </section>

  <section>
    <title>More interesting restrictions</title>

    <mediaobject>
      <imageobject>
        <imagedata align="left" fileref="Gene4.png" />
      </imageobject>
    </mediaobject>

    <para>It is not sufficient for a query language to be merely capable of
    restricting results by a set of restrictions ANDed together. Sometimes one
    wishes to view results where one thing is true OR another thing is true.
    This is represented in our query language by lines leading from the
    restrictions to an operation to perform on those restrictions, as in the
    diagram on the left.</para>

    <mediaobject>
      <imageobject>
        <imagedata align="right" fileref="Gene5.png" />
      </imageobject>
    </mediaobject>

    <para>In this query, all Genes will be listed that have either their "A
    field" field equal to "Hello", or their "Another field" field equal to
    "Bye". The arrows on the blue lines in our diagrams are present so that
    more complex combinations of restrictions are unambiguous. <!--	For example, the diagram on the right describes the OR of two fields together with the AND of two fields, rather than the AND of two fields together with the OR of two fields.-->
    For example, the diagram on the right describes two restrictions being
    ANDed together, with the result ORed with two other restrictions, rather
    than two restrictions ORed together with the result ANDed with two other
    restrictions. The final "where clause" is the AND together of every
    restriction or operation that does not already have an arrow pointing at
    it. The possible operations are AND and OR (which can point to any number
    of restrictions or other operations), plus NOT (which may only point at
    one restriction or operation).</para>
  </section>

  <section>
    <title>Left and right joins</title>

    <mediaobject>
      <imageobject>
        <imagedata align="right" fileref="GeneOtherName.png" />
      </imageobject>
    </mediaobject>

    <para>Sometimes, one may wish to list a selection from a particular object
    type, and also show against each object any objects of a particular type
    that are linked to it - additional information. For example, one may wish
    to list a particular selection of Genes, and get the system to also show
    you any alternative names for that Gene that may exist. If there are no
    alternative names for a given Gene, you still want to see the Gene. In
    this circumstance, one uses a left or right join, which is similar to a
    normal (outer) join except that all of the objects on one side of the join
    are displayed even if they don't participate in the join. We represent
    such a join as a dotted line with an arrow pointing to the "additional
    information" side of the join, as in the diagram on the right. Note:
    left/right joins can lead to inconsistent queries, or queries that do not
    make sense. We have not yet worked out the logic of how and where a left
    or right join is valid. Also, the SQL and OQL representation of left or
    right joins is limited in its expressive power, so it may be a complicated
    task to translate from a query diagram to a valid SQL or OQL query.</para>
  </section>
</article>