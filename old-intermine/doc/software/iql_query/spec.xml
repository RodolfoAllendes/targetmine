<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
  <articleinfo>
    <date>2003-05-19</date>

    <title>InterMine - IQL text-based query specification</title>

    <authorgroup>
      <author>
        <firstname>Matthew</firstname>

        <surname>Wakeling</surname>
      </author>
    </authorgroup>
  </articleinfo>

  <section>
    <title>Introduction</title>

    <para>This document is a specification for the text-based version of the
    InterMine Query, named IQL (InterMine Query Language) after SQL and OQL.
    The language has similar syntax to SQL and OQL, with a few subtle
    differences. The language maps directly onto the InterMine Query Java
    structure - indeed it was constructed specifically so. This is the reason
    for the syntax being as it is.</para>
  </section>

  <section>
    <title>General syntax</title>

    <para>An IQL statement follows the following form:</para>

    <para>SELECT <command>&lt;list of QueryNode objects&gt;</command> FROM
    <command>&lt;list of FromElements (QueryClass objects, or
    subqueries)&gt;</command> [ WHERE <command>&lt;a constraint&gt;</command>
    ] [ GROUP BY <command>&lt;list of QueryNode objects&gt;</command> ] [
    ORDER BY <command>&lt;list of QueryNode objects&gt;</command> ]</para>

    <para>As one can see, an IQL statement is simpler than an SQL statement
    (which has HAVING, LIMIT, and OFFSET clauses). There are no UNIONs or
    anything else particularly fishy.</para>
  </section>

  <section>
    <title>The FROM clause</title>

    <para>The FROM clause contains a list of FromElement objects (which can be
    either QueryClass objects or subqueries). Each element of this list can be
    associated with an alias, by appending " AS
    <command>&lt;alias&gt;</command>" to the element. If a QueryClass does not
    have an alias, then the name of the Class becomes the alias - however
    subqueries <command>must</command> have an alias. There must be no more
    than one instance of each alias in the FROM clause.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>QueryClass objects</emphasis>. The textual
        representation of a QueryClass is merely the name of the java class,
        without the common prefix, which should be supplied along with the
        query. For instance, if one wishes to create a QueryClass for a Class
        of org.intermine.model.testmodel.Manager, and one had a prefix of
        "org.intermine.model.testmodel", one would write "Manager" as the text
        for the required QueryClass.</para>
      </listitem>

      <listitem>
        <para><emphasis>Subqueries</emphasis>. The textual representation of a
        subquery is (like SQL) the entire text of the subquery as an IQL
        query, enclosed inside parentheses. Note that this
        <command>must</command> be followed by an alias.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>QueryNode objects</title>

    <para>There are several types of QueryNode object. A QueryNode is a Java
    interface for all objects that may be present in the SELECT list. The
    implementations of QueryNode are:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>QueryClass</emphasis> - This represents actual objects
        from the database. The textual representation is the alias that was
        specified in the FROM clause.</para>
      </listitem>

      <listitem>
        <para><emphasis>QueryEvaluable</emphasis> - This is an interface for
        various QueryNodes that represent primitive values (type String,
        Number, Boolean, or Date).</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>QueryField</emphasis> - This represents a
            primitive field in an object or subquery, of type String, Number,
            Boolean, or Date. There are several textual representations,
            depending on where the field is from:</para>

            <itemizedlist>
              <listitem>
                <para><emphasis>Field in a QueryClass</emphasis>. The textual
                representation is the alias of the QueryClass (in the FROM
                clause), followed by a dot, followed by the name of the field
                - for example "<command>SELECT Company.name as field FROM
                Company</command>".</para>
              </listitem>

              <listitem>
                <para><emphasis>Field from a field present in a
                subquery</emphasis>. The textual representation is the alias
                of the subquery, followed by a dot, followed by the name of
                the field, as aliased in the subquery - for example
                "<command>SELECT subquery.thing as field FROM (SELECT
                Company.name as thing FROM Company) as
                subquery</command>".</para>
              </listitem>

              <listitem>
                <para><emphasis>Field from a QueryClass, in a
                subquery</emphasis>. The textual representation is the alias
                of the subquery, followed by a dot, followed by the name of
                the QueryClass, as aliased in the subquery, followed by
                another dot, followed by the name of the field - for example
                "<command>SELECT subquery.Company.name as field FROM (SELECT
                Company from Company) as subquery</command>".</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><emphasis>QueryValue</emphasis> - This represents a constant
            value. The textual representation depends on the type of the
            constant to be represented:</para>

            <itemizedlist>
              <listitem>
                <para><emphasis>Number</emphasis>. The textual representation
                is as a normal number with no embellishment. The exact type of
                the number is deduced from how it is used in the Query.</para>
              </listitem>

              <listitem>
                <para><emphasis>String</emphasis>. The textual representation
                is with single quotes enclosing the required String.</para>
              </listitem>

              <listitem>
                <para><emphasis>Boolean</emphasis>. The textual representation
                is "<command>true</command>" or
                "<command>false</command>".</para>
              </listitem>

              <listitem>
                <para><emphasis>Date</emphasis>. The textual representation is
                "<command>'yyyy-MM-dd HH:mm:ss.SSS'</command>", including the
                single quotes enclosing it. <emphasis>Note: This definition
                overlaps with that of a String. A Date is distinguished from a
                String by how it is used in the Query.</emphasis></para>
              </listitem>
            </itemizedlist>

            <para>If, while converting an IQL query to a Java Query, the type
            of a QueryValue cannot be distinguished, then an UnknownTypeValue
            is used, which merely holds the textual representation of the
            value.</para>
          </listitem>

          <listitem>
            <para><emphasis>QueryFunction</emphasis> - This represents an
            aggregate function. Most of these functions require a single
            argument, which should be a QueryField, or maybe a
            QueryExpression. The presence of an aggregate function in a query
            means that either the entire set of rows of the query are rolled
            together into one row with the results of the aggregate function,
            or the entire set of rows of the query are rolled into multiple
            groups of rows, dictated by the contents of the GROUP BY clause,
            if it exists. The textual representation of these functions
            is:</para>

            <itemizedlist>
              <listitem>
                <para><emphasis>COUNT(*)</emphasis> - this evaluates to the
                number of rows in the group it represents.</para>
              </listitem>

              <listitem>
                <para><emphasis>MIN(<command>&lt;QueryEvaluable&gt;</command>)</emphasis>
                - this evaluates to the minimum value of the QueryEvaluable
                mentioned in the group of rows it represents.</para>
              </listitem>

              <listitem>
                <para><emphasis>MAX(<command>&lt;QueryEvaluable&gt;</command>)</emphasis>
                - this evaluates to the maximum value of the QueryEvaluable
                mentioned in the group of rows it represents.</para>
              </listitem>

              <listitem>
                <para><emphasis>SUM(<command>&lt;QueryEvaluable&gt;</command>)</emphasis>
                - this evaluates to the sum of all the values of the
                QueryEvaluable mentioned in the group of rows it
                represents.</para>
              </listitem>

              <listitem>
                <para><emphasis>AVG(<command>&lt;QueryEvaluable&gt;</command>)</emphasis>
                - this evaluates to the average of all the value of the
                QueryEvaluable mentioned in the group of rows it
                represents.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><emphasis>QueryExpression</emphasis> - This represents an
            arithmetic expression, comprised of two other QueryEvaluables
            (QueryValue, QueryField, QueryFunction, or QueryExpression) and an
            operation, or a substring operation with three QueryEvaluable
            arguments. The three types are:</para>

            <itemizedlist>
              <listitem>
                <para><emphasis><command>&lt;QueryEvaluable&gt;</command> {+,
                -, *, /} <command>&lt;QueryEvaluable&gt;</command></emphasis>
                - Normal arithmetic expressions.</para>
              </listitem>

              <listitem>
                <para><emphasis>INDEXOF(<command>&lt;QueryEvaluable&gt;</command>,
                <command>&lt;QueryEvaluable&gt;</command>)</emphasis> - the
                result of the expression is the index of the second argument
                (a String) in the first argument (also a String), where the
                character positions are numbered from one, or a result of zero
                if the second argument does not occur in the first
                argument.</para>
              </listitem>

              <listitem>
                <para><emphasis>SUBSTR(<command>&lt;QueryEvaluable&gt;</command>,
                <command>&lt;QueryEvaluable&gt;</command>,
                <command>&lt;QueryEvaluable&gt;</command>)</emphasis> - The
                result of the expression is the substring of the first
                argument, from the character numbered from 1 from the left
                determined by the second argument, and as many characters to
                the right as determined by the third argument or the end of
                the first argument being reached.</para>
              </listitem>
            </itemizedlist>
          </listitem>

          <listitem>
            <para><emphasis>QueryCast</emphasis> - This represents a typecast
            from one type of value to another. One cannot cast to a primitive
            type (int, long, etc.), but to java Classes (Integer, Long, etc).
            Some typecasts may not make sense, so an error may occur when the
            query is run. Due to the storage format of Date objects, typecasts
            involving them may not act as expected. The textual representation
            is:</para>

            <itemizedlist>
              <listitem>
                <para><emphasis><command>&lt;QueryEvaluable&gt;</command>::<command>&lt;class
                name (Short, Integer, Long, Float, Double, BigDecimal,
                Boolean, Date, String)&gt;</command></emphasis></para>
              </listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>

    <para>These QueryNodes can be used in the SELECT, GROUP BY, and ORDER BY
    clauses, as well as inside different constraints. However, elements in the
    SELECT list need to have aliases - except QueryClasses (which already have
    an alias specified in the FROM list)</para>
  </section>

  <section>
    <title>Constraints and the WHERE clause</title>

    <para>The WHERE clause contains a single constraint of some kind, where
    that constraint may contain other constraints. These are the different
    kinds of constraint:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>SimpleConstraint</emphasis> - This type of constraint
        performs the comparison between different QueryEvaluables. It has two
        forms - a comparison between a QueryEvaluable and NULL, and a
        comparison between two QueryEvaluables.</para>

        <itemizedlist>
          <listitem>
            <para><emphasis><command>&lt;QueryEvaluable&gt;</command> {=, !=,
            &lt;, &lt;=, &gt;, &gt;=, LIKE, NOT LIKE}
            <command>&lt;QueryEvaluable&gt;</command></emphasis> - Returns
            true if the condition is satisfied. Note that "=" and "!=" are
            available to all QueryEvaluable types, but "&lt;", "&lt;=",
            "&gt;", "&gt;=" are only available to numeric QueryEvaluable
            types, and "LIKE" and "NOT LIKE" are only available to String
            QueryEvaluable types. The two QueryEvaluables must have matching
            types.</para>
          </listitem>

          <listitem>
            <para><emphasis><command>&lt;QueryEvaluable&gt;</command> IS [NOT]
            NULL</emphasis> - Returns true if the condition is
            satisfied.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para><emphasis>ClassConstraint</emphasis> - This is a comparison
        between two QueryClasses as specified in the FROM clause. The textual
        representation is the first QueryClass, followed by "=" or "!=",
        followed by the second QueryClass.</para>
      </listitem>

      <listitem>
        <para><emphasis>ContainsConstraint</emphasis> - This is a comparison
        between a reference type member of a QueryClass, and a QueryClass that
        the reference may contain. There are two types of reference which can
        be present in an object - an object reference (which references a
        single object), and a collection reference (which is represented in
        the object as a Collection containing multiple objects). Nevertheless,
        both types of reference are treated exactly the same in IQL - the only
        noticeable difference between them being that collections are often
        named with a plural-like name (for instance "departments"). So, even
        though you may wish to write "<command>Department.company =
        Company</command>", the correct syntax is "<command>Department.company
        CONTAINS Company</command>". The textual representation is a reference
        type (represented as the QueryClass followed by a dot, followed by the
        name of the reference), followed by "CONTAINS" or "DOES NOT CONTAIN",
        followed by the QueryClass being referred to. For example -
        "<command>Company.departments CONTAINS Department</command>".</para>
      </listitem>

      <listitem>
        <para><emphasis>SubqueryConstraint</emphasis> - This is a comparison
        between the results of a subquery, and a QueryClass or a
        QueryEvaluable. The constraint will return true if the value of the
        QueryClass or QueryEvaluable is present (or not present) in one of the
        rows of the results of the subquery. The textual representation is the
        QueryClass or QueryEvaluable, followed by "IN" or "NOT IN", followed
        by an IQL query statement with only one element in the SELECT list,
        enclosed in parentheses. For example "<command>Company.name IN (SELECT
        Company.name AS name FROM Company)</command>".</para>
      </listitem>

      <listitem>
        <para><emphasis>NotConstraint</emphasis> - This isn't actually a
        InterMine Query Java object - but it is a textual representation of
        negating the result of any Constraint. The textual representation is
        "NOT", followed by the Constraint to reverse. If In Doubt, Use
        Brackets. For example "<command>NOT Company.name =
        Department.name</command>".</para>
      </listitem>

      <listitem>
        <para><emphasis>ConstraintSet</emphasis> - This represents a set of
        multiple constraints that have been combined with the AND or OR
        operators. The textual representation is a string of any number of
        Constraints, separated by "AND" or "OR" - again If In Doubt, Use
        Brackets. For example "<command>Company.name = Department.name AND
        (Company.vatNumber = 3 OR Company.name = 'flobble') AND
        Department.name != 'wotsit'</command>".</para>
      </listitem>
    </itemizedlist>
  </section>
</article>